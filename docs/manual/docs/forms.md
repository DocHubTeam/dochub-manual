Ghj,f JSONSchema. 
# Формы (forms)

Подход "Архитектура как код" (AaaC) не всегда оказывается удобным для пользователей архитектурного репозитория. 
Привыкшие к классическим UI-интерфейсам пользователи, могут столкнуться с трудностями при взаимодействии
с архитектурным репозиторием на первом этапе. Чтобы облегчить их опыт и предложить привычные методы работы
с репозиторием, по крайней мере на начальном этапе, DocHub предлагает динамические UI-формы.

## Простой пример динамической формы

Пример описания формы:
```code-frame
docs/dochub.forms.examples.simple
```
Данная форма позволяет заполнять данные о пользователе в привычной для него форме. В текущем виде она не позволяет сохранять 
введенные данные или манипулировать ими, но мы можем посмотреть как работает ввод и проверка корректности ее заполнения.

Встраивание формы в документы осуществляется обычным методом встройки объектов:
```
![Форма](@document/dochub.forms.examples.simple)
```

Результат встройки выглядит так:
![Форма](@document/dochub.forms.examples.simple)

## Схема данных формы

Конфигурацию формы необходимо определить в свойстве документа **source**. Она должна иметь определенную структуру:
```yaml
...
    source:
      schema: <JSONSchema формы>  # Обязательно. Именно по этой схеме происходит построение формы
      data: <данные>/<JSONata>    # Необязательно. Данные для предварительного заполнения формы
      triggers:                   # Необязательно. Здесь декларируются триггеры формы
        change: <JSONata>         # Необязательно. Выполняется при изменении данных в форме
        validate: <JSONata>       # Необязательно. Алгоритмическая проверка заполнения формы
        post: <JSONata>           # Необязательно. Обработчик данных перед сохранением
...
```

Конфигурация может быть определена как константа или запрос JSONata. Например, доступен такой метод: 

```yaml
...
    source: >
      (
        {
          "schema": {
            "type": "object",
            "properties": {
              "a": {
                "type": "number"
              }
            },
            "required": ["a"]
          },
          "data": {
            "a": 10
          }
        }
      )
...
```
Такой подход позволяет создавать формы "на лету".

## Триггеры формы

Формы могут выполнять действия по триггерам. Обработчики триггеров реализуются на JSONata. При наступлении события
вызывается соответствующий обработчик, в который передаются необходимые переменные:

* **\$**                      - DataLake.
* **\$self**                  - профиль презентации;
* **\$params**                - переданные параметры при вызове презентации;
* **\$params.\$form**         - данные формы;
* **\$params.\$form.data**    - заполненные данные формы;
* **\$params.\$form.changes** - пути к измененным свойствам.

Существуют следующие триггеры:

* **change**     - вызывается при изменении значения одного из полей;
* **validate**   - вызывается после заполнения формы для проверки на ошибки;
* **post**       - вызывается при нажатии кнопки сохранения.

### Триггер change

Для примера создадим форму сложения двух чисел.
```code-frame
docs/dochub.forms.examples.summ
```
![Форма сложения чисел](@document/dochub.forms.examples.summ)

### Триггер validate

Динамические формы имеют встроенную подсистему контроля заполнения формы, которая использует JSONSchema.
Но в некоторых случаях этого недостаточно. Эту проблему можно решить с помощью триггера **validate**.
Он вызывается при завершении заполнения формы, когда данные в ней полностью соответствуют декларированной
JSONSchema.

В будущем мы будем сохранять результат вычисления в DataLake. Представим себе, что корректным для сохранения 
результатом может быть только четное число. Для контроля корректности в форму добавляется триггер **validate**.

```code-frame
docs/dochub.forms.examples.validate
```
В результате работы треггера, если ошибки обнаружены, он должен вернуть структуру или массив структур с описанием
ошибок в следующем формате:
```json
  [
    {
      message: <описание ошибки>,
      path: [<путь к полю с ошибкой>]
    }
    ...
  ]
```

Чтобы увидеть работу триггера в действии необходимо после вычисления результата нажать кнопку "Проверить"/"Validate".

![Форма сложения чисел с алгоритмической проверкой](@document/dochub.forms.examples.validate)

### Триггер post

Результат работы формы можно сохранять в архитектурном репозитории (DataLake). При сохранении форма генерирует изменения
в архитектурном коде, как если бы это сделал человек. Для реализации этой функции необходимо создать триггер **post**. 

```code-frame
docs/dochub.forms.examples.post
```

В коде мы возвращаем путь "docs/dochub.forms.examples.post/data". Этот путь затрагивает декларацию самой формы, которая
сохраняет данные. При сохранении вы увидите, что код выше изменится, в нем отразится поле "data" с введенными вами
данными. Это наглядная демонстрация того, что сохранение формы приводит к модификации кода репозитория, добавляя в него
поле "data".

![Форма сохранения вычисления в репозитории](@document/dochub.forms.examples.post)

## Предварительное заполнение формы данными

Часто требуется предзаполнить форму данными. Для этого в **source** необходимо вернуть данные в поле **data**.

Для демонстрации этой возможности еще усложним пример калькулятора и добавим восстановление последних сохраненных
значений.

```code-frame
docs/dochub.forms.examples.restore_data
```

В результате, после вычисления значения и его сохранения, форма будет запускаться с уже ранее рассчитанными значениями.

![Форма сложения чисел с восстановлением значений](@document/dochub.forms.examples.restore_data)


## Табличные формы

Формы могут содержать таблицы. Для декларации табличной части формы необходимо использовать тип **array** в JSONSchema.

```code-frame
docs/dochub.forms.examples.table.simple
```

Пример работы формы:
![Табличная форма](@document/dochub.forms.examples.table.simple)

[Далее](/docs/dochub.entities)

## Форматы полей

Для удобного пользовательского ввода существует несколько типов полей. Тип поля определяется свойством **format** в JSONSchema.

Разнообразие полей в динамических формах напрямую связано со спецификацией JSONSchema. Схема декларации формы строго
соответствует спецификации JSONSchema. Это позволяет универсально использовать схемы в DocHub. Например, декларация
схемы данных сущности легко может быть преобразована в форму.

Базовые поведение полей на форме определяются через стандартное поле **format**.

```code-frame
docs/dochub.forms.examples.fields
```
Пример работы полей:
![Виды полей формы](@document/dochub.forms.examples.fields)

## Расширенные свойства полей

Не всегда удается удовлетворить потребности по управлению поведением полей на форме стандартными свойствами спецификации
JSON Schema.

Для решения возникающих проблем используются специальные, расширенные свойства имеющие формат **x-<идентификатор поля>**

Для реализации поведения формами используются следующие расширенные свойства:

* **x-validator**  - Алгоритм проверки значения поля;
* **x-dataset**    - Набор данных, который используется для выбора предопределенных значений;
* **x-col**        - количество ячеек строки таблицы, которое поле будет занимать на форме.

